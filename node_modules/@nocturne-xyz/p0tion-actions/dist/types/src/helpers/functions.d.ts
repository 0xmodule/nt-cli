import { Functions } from "firebase/functions";
import { CeremonyInputData, CircuitDocument, ETagWithPartNumber, FirebaseDocumentInfo } from "../types/index";
/**
 * Setup a new ceremony by calling the related cloud function.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyInputData <CeremonyInputData> - the input data of the ceremony.
 * @param ceremonyPrefix <string> - the prefix of the ceremony.
 * @param circuits <Circuit[]> - the circuits data.
 * @returns Promise<string> - the unique identifier of the created ceremony.
 */
export declare const setupCeremony: (functions: Functions, ceremonyInputData: CeremonyInputData, ceremonyPrefix: string, circuits: CircuitDocument[]) => Promise<string>;
/**
 * Check the user's current participant status for the ceremony
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @returns <boolean> - true when participant is able to contribute; otherwise false.
 */
export declare const checkParticipantForCeremony: (functions: Functions, ceremonyId: string) => Promise<any>;
/**
 * Progress the participant to the next circuit preparing for the next contribution.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 */
export declare const progressToNextCircuitForContribution: (functions: Functions, ceremonyId: string) => Promise<void>;
/**
 * Resume the contributor circuit contribution from scratch after the timeout expiration.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 */
export declare const resumeContributionAfterTimeoutExpiration: (functions: Functions, ceremonyId: string) => Promise<void>;
/**
 * Make a request to create a new AWS S3 bucket for a ceremony.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 */
export declare const createS3Bucket: (functions: Functions, bucketName: string) => Promise<void>;
/**
 * Return a pre-signed url for a given object contained inside the provided AWS S3 bucket in order to perform a GET request.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param objectKey <string> - the storage path that locates the artifact to be downloaded in the bucket.
 * @returns <Promise<string>> - the pre-signed url w/ GET request permissions for specified object key.
 */
export declare const generateGetObjectPreSignedUrl: (functions: Functions, bucketName: string, objectKey: string) => Promise<string>;
/**
 * Progress the participant to the next circuit preparing for the next contribution.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 */
export declare const progressToNextContributionStep: (functions: Functions, ceremonyId: string) => Promise<void>;
/**
 * Write the information about current contribution hash and computation time for the current contributor.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param contributionComputationTime <number> - the time when it was computed
 * @param contributingHash <string> - the hash of the contribution
 */
export declare const permanentlyStoreCurrentContributionTimeAndHash: (functions: Functions, ceremonyId: string, contributionComputationTime: number, contributionHash: string) => Promise<void>;
/**
 * Start a new multi-part upload for a specific object in the given AWS S3 bucket.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param objectKey <string> - the storage path that locates the artifact to be downloaded in the bucket.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @returns Promise<string> - the multi-part upload id.
 */
export declare const openMultiPartUpload: (functions: Functions, bucketName: string, objectKey: string, ceremonyId?: string) => Promise<string>;
/**
 * Write temporary information about the unique identifier about the opened multi-part upload to eventually resume the contribution.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param uploadId <string> - the unique identifier of the multi-part upload.
 */
export declare const temporaryStoreCurrentContributionMultiPartUploadId: (functions: Functions, ceremonyId: string, uploadId: string) => Promise<void>;
/**
 * Write temporary information about the etags and part numbers for each uploaded chunk in order to make the upload resumable from last chunk.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param chunk <ETagWithPartNumber> - the information about the already uploaded chunk.
 */
export declare const temporaryStoreCurrentContributionUploadedChunkData: (functions: Functions, ceremonyId: string, chunk: ETagWithPartNumber) => Promise<void>;
/**
 * Generate a new pre-signed url for each chunk related to a started multi-part upload.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param objectKey <string> - the storage path that locates the artifact to be downloaded in the bucket.
 * @param uploadId <string> - the unique identifier of the multi-part upload.
 * @param numberOfChunks <number> - the number of pre-signed urls to be generated.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @returns Promise<Array<string>> - the set of pre-signed urls (one for each chunk).
 */
export declare const generatePreSignedUrlsParts: (functions: Functions, bucketName: string, objectKey: string, uploadId: string, numberOfParts: number, ceremonyId?: string) => Promise<Array<string>>;
/**
 * Complete a multi-part upload for a specific object in the given AWS S3 bucket.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param objectKey <string> - the storage path that locates the artifact to be downloaded in the bucket.
 * @param uploadId <string> - the unique identifier of the multi-part upload.
 * @param parts Array<ETagWithPartNumber> - the completed .
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @returns Promise<string> - the location of the uploaded ceremony artifact.
 */
export declare const completeMultiPartUpload: (functions: Functions, bucketName: string, objectKey: string, uploadId: string, parts: Array<ETagWithPartNumber>, ceremonyId?: string) => Promise<string>;
/**
 * Check if a specified object exist in a given AWS S3 bucket.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param objectKey <string> - the storage path that locates the artifact to be downloaded in the bucket.
 * @returns <Promise<string>> - true if and only if the object exists, otherwise false.
 */
export declare const checkIfObjectExist: (functions: Functions, bucketName: string, objectKey: string) => Promise<boolean>;
/**
 * Request to verify the newest contribution for the circuit.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param circuit <FirebaseDocumentInfo> - the document info about the circuit.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param contributorOrCoordinatorIdentifier <string> - the identifier of the contributor or coordinator (only when finalizing).
 * @param verifyContributionCloudFunctionEndpoint <string> - the endpoint (direct url) necessary to call the V2 Cloud Function.
 * @returns <Promise<void>> -
 */
export declare const verifyContribution: (functions: Functions, ceremonyId: string, circuit: FirebaseDocumentInfo, bucketName: string, contributorOrCoordinatorIdentifier: string, verifyContributionCloudFunctionEndpoint: string) => Promise<void>;
/**
 * Prepare the coordinator for the finalization of the ceremony.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @returns <Promise<boolean>> - true when the coordinator is ready for finalization; otherwise false.
 */
export declare const checkAndPrepareCoordinatorForFinalization: (functions: Functions, ceremonyId: string) => Promise<boolean>;
/**
 * Finalize the ceremony circuit.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param circuitId <string> - the unique identifier of the circuit.
 * @param bucketName <string> - the name of the ceremony bucket.
 * @param beacon <string> - the value used to compute the final contribution while finalizing the ceremony.
 */
export declare const finalizeCircuit: (functions: Functions, ceremonyId: string, circuitId: any, bucketName: string, beacon: string) => Promise<void>;
/**
 * Conclude the finalization of the ceremony.
 * @param functions <Functions> - the Firebase cloud functions object instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 */
export declare const finalizeCeremony: (functions: Functions, ceremonyId: string) => Promise<void>;
//# sourceMappingURL=functions.d.ts.map