/// <reference types="node" />
import { Firestore } from "firebase/firestore";
import { ReadPosition } from "fs";
import winston, { Logger } from "winston";
import { CircuitMetadata, Contribution, ContributionValidity, FirebaseDocumentInfo, SetupCeremonyData } from "../types/index";
/**
 * Parse and validate that the ceremony configuration is correct
 * @notice this does not upload any files to storage
 * @param path <string> - the path to the configuration file
 * @param cleanup <boolean> - whether to delete the r1cs file after parsing
 * @returns any - the data to pass to the cloud function for setup and the circuit artifacts
 */
export declare const parseCeremonyFile: (path: string, cleanup?: boolean) => Promise<SetupCeremonyData>;
/**
 * Extract data from a R1CS metadata file generated with a custom file-based logger.
 * @notice useful for extracting metadata circuits contained in the generated file using a logger
 * on the `r1cs.info()` method of snarkjs.
 * @param fullFilePath <string> - the full path of the file.
 * @param keyRgx <RegExp> - the regular expression linked to the key from which you want to extract the value.
 * @returns <string> - the stringified extracted value.
 */
export declare const extractR1CSInfoValueForGivenKey: (fullFilePath: string, keyRgx: RegExp) => string;
/**
 * Calculate the smallest amount of Powers of Tau needed for a circuit with a constraint size.
 * @param constraints <number> - the number of circuit constraints (extracted from metadata).
 * @param outputs <number> - the number of circuit outputs (extracted from metadata)
 * @returns <number> - the smallest amount of Powers of Tau for the given constraint size.
 */
export declare const computeSmallestPowersOfTauForCircuit: (constraints: number, outputs: number) => number;
/**
 * Transform a number in a zKey index format.
 * @dev this method is aligned with the number of characters of the genesis zKey index (which is a constant).
 * @param progress <number> - the progression in zKey index.
 * @returns <string> - the progression in a zKey index format (`XYZAB`).
 */
export declare const formatZkeyIndex: (progress: number) => string;
/**
 * Extract the amount of powers from Powers of Tau file name.
 * @dev the PoT files must follow these convention (i_am_a_pot_file_09.ptau) where the numbers before '.ptau' are the powers.
 * @param potCompleteFilename <string> - the complete filename of the Powers of Tau file.
 * @returns <number> - the amount of powers.
 */
export declare const extractPoTFromFilename: (potCompleteFilename: string) => number;
/**
 * Extract a prefix consisting of alphanumeric and underscore characters from a string with arbitrary characters.
 * @dev replaces all special symbols and whitespaces with an underscore char ('_'). Convert all uppercase chars to lowercase.
 * @notice example: str = 'Multiplier-2!2.4.zkey'; output prefix = 'multiplier_2_2_4.zkey'.
 * NB. Prefix extraction is a key process that conditions the name of the ceremony artifacts, download/upload from/to storage, collections paths.
 * @param str <string> - the arbitrary string from which to extract the prefix.
 * @returns <string> - the resulting prefix.
 */
export declare const extractPrefix: (str: string) => string;
/**
 * Automate the generation of an entropy for a contribution.
 * @dev Took inspiration from here https://github.com/glamperd/setup-mpc-ui/blob/master/client/src/state/Compute.tsx#L112.
 * @todo we need to improve the entropy generation (too naive).
 * @returns <string> - the auto-generated entropy.
 */
export declare const autoGenerateEntropy: () => string;
/**
 * Check and return the circuit document based on its sequence position among a set of circuits (if any).
 * @dev there should be only one circuit with a provided sequence position. This method checks and return an
 * error if none is found.
 * @param circuits <Array<FirebaseDocumentInfo>> - the set of ceremony circuits documents.
 * @param sequencePosition <number> - the sequence position (index) of the circuit to be found and returned.
 * @returns <FirebaseDocumentInfo> - the document of the circuit in the set of circuits that has the provided sequence position.
 */
export declare const getCircuitBySequencePosition: (circuits: Array<FirebaseDocumentInfo>, sequencePosition: number) => FirebaseDocumentInfo;
/**
 * Convert bytes or chilobytes into gigabytes with customizable precision.
 * @param bytesOrKb <number> - the amount of bytes or chilobytes to be converted.
 * @param isBytes <boolean> - true when the amount to be converted is in bytes; otherwise false (= Chilobytes).
 * @returns <number> - the converted amount in GBs.
 */
export declare const convertBytesOrKbToGb: (bytesOrKb: number, isBytes: boolean) => number;
/**
 * Get the validity of contributors' contributions for each circuit of the given ceremony (if any).
 * @param firestoreDatabase <Firestore> - the Firestore service instance associated to the current Firebase application.
 * @param circuits <Array<FirebaseDocumentInfo>> - the array of ceremony circuits documents.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param participantId <string> - the unique identifier of the contributor.
 * @param isFinalizing <boolean> - flag to discriminate between ceremony finalization (true) and contribution (false).
 * @returns <Promise<Array<ContributionValidity>>> - a list of contributor contributions together with contribution validity (based on coordinator verification).
 */
export declare const getContributionsValidityForContributor: (firestoreDatabase: Firestore, circuits: Array<FirebaseDocumentInfo>, ceremonyId: string, participantId: string, isFinalizing: boolean) => Promise<Array<ContributionValidity>>;
/**
 * Return the public attestation preamble for given contributor.
 * @param contributorIdentifier <string> - the identifier of the contributor (handle, name, uid).
 * @param ceremonyName <string> - the name of the ceremony.
 * @param isFinalizing <boolean> - true when the coordinator is finalizing the ceremony, otherwise false.
 * @returns <string> - the public attestation preamble.
 */
export declare const getPublicAttestationPreambleForContributor: (contributorIdentifier: string, ceremonyName: string, isFinalizing: boolean) => string;
/**
 * Check and prepare public attestation for the contributor made only of its valid contributions.
 * @param firestoreDatabase <Firestore> - the Firestore service instance associated to the current Firebase application.
 * @param circuits <Array<FirebaseDocumentInfo>> - the array of ceremony circuits documents.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param participantId <string> - the unique identifier of the contributor.
 * @param participantContributions <Array<Co> - the document data of the participant.
 * @param contributorIdentifier <string> - the identifier of the contributor (handle, name, uid).
 * @param ceremonyName <string> - the name of the ceremony.
 * @param isFinalizing <boolean> - true when the coordinator is finalizing the ceremony, otherwise false.
 * @returns <Promise<[string, string[]]>> - the public attestation for the contributor followed by the concatenated hashes of the contributions for each circuit
 */
export declare const generateValidContributionsAttestation: (firestoreDatabase: Firestore, circuits: Array<FirebaseDocumentInfo>, ceremonyId: string, participantId: string, participantContributions: Array<Contribution>, contributorIdentifier: string, ceremonyName: string, isFinalizing: boolean) => Promise<[string, string[]]>;
/**
 * Create a custom logger to write logs on a local file.
 * @param filename <string> - the name of the output file (where the logs are going to be written).
 * @param level <winston.LoggerOptions["level"]> - the option for the logger level (e.g., info, error).
 * @returns <Logger> - a customized winston logger for files.
 */
export declare const createCustomLoggerForFile: (filename: string, level?: winston.LoggerOptions["level"]) => Logger;
/**
 * Return an amount of bytes read from a file to a particular location in the form of a buffer.
 * @param localFilePath <string> - the local path where the artifact will be downloaded.
 * @param offset <number> - the index of the line to be read (0 from the start).
 * @param length <number> - the length of the line to be read.
 * @param position <ReadPosition> - the position inside the file.
 * @returns <Buffer> - the buffer w/ the read bytes.
 */
export declare const readBytesFromFile: (localFilePath: string, offset: number, length: number, position: ReadPosition) => Buffer;
/**
 * Return the info about the R1CS file.Ã¹
 * @dev this method was built taking inspiration from
 * https://github.com/weijiekoh/circom-helper/blob/master/ts/read_num_inputs.ts#L5.
 * You can find the specs of R1CS file here
 * https://github.com/iden3/r1csfile/blob/master/doc/r1cs_bin_format.md
 * @param localR1CSFilePath <string> - the local path to the R1CS file.
 * @returns <CircuitMetadata> - the info about the R1CS file.
 */
export declare const getR1CSInfo: (localR1CSFilePath: string) => CircuitMetadata;
/**
 * Return a string with double digits if the provided input is one digit only.
 * @param in <number> - the input number to be converted.
 * @returns <string> - the two digits stringified number derived from the conversion.
 */
export declare const convertToDoubleDigits: (amount: number) => string;
//# sourceMappingURL=utils.d.ts.map