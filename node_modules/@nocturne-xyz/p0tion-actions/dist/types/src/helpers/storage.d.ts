import { Functions } from "firebase/functions";
import { ETagWithPartNumber, ChunkWithUrl, TemporaryParticipantContributionData } from "../types/index";
import { GenericBar } from "cli-progress";
/**
 * Return the bucket name based on ceremony prefix.
 * @param ceremonyPrefix <string> - the ceremony prefix.
 * @param ceremonyPostfix <string> - the ceremony postfix.
 * @returns <string>
 */
export declare const getBucketName: (ceremonyPrefix: string, ceremonyPostfix: string) => string;
/**
 * Get chunks and signed urls related to an object that must be uploaded using a multi-part upload.
 * @param cloudFunctions <Functions> - the Firebase Cloud Functions service instance.
 * @param bucketName <string> - the name of the ceremony artifacts bucket (AWS S3).
 * @param objectKey <string> - the unique key to identify the object inside the given AWS S3 bucket.
 * @param localFilePath <string> - the local path where the artifact will be downloaded.
 * @param uploadId <string> - the unique identifier of the multi-part upload.
 * @param configStreamChunkSize <number> - size of each chunk into which the artifact is going to be splitted (nb. will be converted in MB).
 * @param [ceremonyId] <string> - the unique identifier of the ceremony.
 * @returns Promise<Array<ChunkWithUrl>> - the chunks with related pre-signed url.
 */
export declare const getChunksAndPreSignedUrls: (cloudFunctions: Functions, bucketName: string, objectKey: string, localFilePath: string, uploadId: string, configStreamChunkSize: number, ceremonyId?: string) => Promise<Array<ChunkWithUrl>>;
/**
 * Forward the request to upload each single chunk of the related ceremony artifact.
 * @param chunksWithUrls <Array<ChunkWithUrl>> - the array containing each chunk mapped with the corresponding pre-signed urls.
 * @param contentType <string | false> - the content type of the ceremony artifact.
 * @param cloudFunctions <Functions> - the Firebase Cloud Functions service instance.
 * @param ceremonyId <string> - the unique identifier of the ceremony.
 * @param alreadyUploadedChunks Array<ETagWithPartNumber> - the temporary information about the already uploaded chunks.
 * @returns <Promise<Array<ETagWithPartNumber>>> - the completed (uploaded) chunks information.
 */
export declare const uploadParts: (chunksWithUrls: Array<ChunkWithUrl>, contentType: string | false, cloudFunctions?: Functions, ceremonyId?: string, alreadyUploadedChunks?: Array<ETagWithPartNumber>, logger?: GenericBar) => Promise<Array<ETagWithPartNumber>>;
/**
 * Upload a ceremony artifact to the corresponding bucket.
 * @notice this method implements the multi-part upload using pre-signed urls, optimal for large files.
 * Steps:
 * 0) Check if current contributor could resume a multi-part upload.
 *    0.A) If yes, continue from last uploaded chunk using the already opened multi-part upload.
 *    0.B) Otherwise, start creating a new multi-part upload.
 * 1) Generate a pre-signed url for each (remaining) chunk of the ceremony artifact.
 * 2) Consume the pre-signed urls to upload chunks.
 * 3) Complete the multi-part upload.
 * @param cloudFunctions <Functions> - the Firebase Cloud Functions service instance.
 * @param bucketName <string> - the name of the ceremony artifacts bucket (AWS S3).
 * @param objectKey <string> - the unique key to identify the object inside the given AWS S3 bucket.
 * @param localPath <string> - the local path where the artifact will be downloaded.
 * @param configStreamChunkSize <number> - size of each chunk into which the artifact is going to be splitted (nb. will be converted in MB).
 * @param [ceremonyId] <string> - the unique identifier of the ceremony (used as a double-edge sword - as identifier and as a check if current contributor is the coordinator finalizing the ceremony).
 * @param [temporaryDataToResumeMultiPartUpload] <TemporaryParticipantContributionData> - the temporary information necessary to resume an already started multi-part upload.
 */
export declare const multiPartUpload: (cloudFunctions: Functions, bucketName: string, objectKey: string, localFilePath: string, configStreamChunkSize: number, ceremonyId?: string, temporaryDataToResumeMultiPartUpload?: TemporaryParticipantContributionData, logger?: GenericBar) => Promise<void>;
/**
 * Download an artifact from S3 (only for authorized users)
 * @param cloudFunctions <Functions> Firebase cloud functions instance.
 * @param bucketName <string> Name of the bucket where the artifact is stored.
 * @param storagePath <string> Path to the artifact in the bucket.
 * @param localPath <string> Path to the local file where the artifact will be saved.
 */
export declare const downloadCeremonyArtifact: (cloudFunctions: Functions, bucketName: string, storagePath: string, localPath: string) => Promise<void>;
/**
 * Get R1CS file path tied to a particular circuit of a ceremony in the storage.
 * @notice each R1CS file in the storage must be stored in the following path: `circuits/<circuitPrefix>/<completeR1csFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeR1csFilename <string> - the complete R1CS filename (name + ext).
 * @returns <string> - the storage path of the R1CS file.
 */
export declare const getR1csStorageFilePath: (circuitPrefix: string, completeR1csFilename: string) => string;
/**
 * Get WASM file path tied to a particular circuit of a ceremony in the storage.
 * @notice each WASM file in the storage must be stored in the following path: `circuits/<circuitPrefix>/<completeWasmFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeWasmFilename <string> - the complete WASM filename (name + ext).
 * @returns <string> - the storage path of the WASM file.
 */
export declare const getWasmStorageFilePath: (circuitPrefix: string, completeWasmFilename: string) => string;
/**
 * Get PoT file path in the storage.
 * @notice each PoT file in the storage must be stored in the following path: `pot/<completePotFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param completePotFilename <string> - the complete PoT filename (name + ext).
 * @returns <string> - the storage path of the PoT file.
 */
export declare const getPotStorageFilePath: (completePotFilename: string) => string;
/**
 * Get zKey file path tied to a particular circuit of a ceremony in the storage.
 * @notice each zKey file in the storage must be stored in the following path: `circuits/<circuitPrefix>/contributions/<completeZkeyFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeZkeyFilename <string> - the complete zKey filename (name + ext).
 * @returns <string> - the storage path of the zKey file.
 */
export declare const getZkeyStorageFilePath: (circuitPrefix: string, completeZkeyFilename: string) => string;
/**
 * Get verification key file path tied to a particular circuit of a ceremony in the storage.
 * @notice each verification key file in the storage must be stored in the following path: `circuits/<circuitPrefix>/<completeVerificationKeyFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeVerificationKeyFilename <string> - the complete verification key filename (name + ext).
 * @returns <string> - the storage path of the verification key file.
 */
export declare const getVerificationKeyStorageFilePath: (circuitPrefix: string, completeVerificationKeyFilename: string) => string;
/**
 * Get verifier contract file path tied to a particular circuit of a ceremony in the storage.
 * @notice each verifier contract file in the storage must be stored in the following path: `circuits/<circuitPrefix>/<completeVerificationKeyFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeVerifierContractFilename <string> - the complete verifier contract filename (name + ext).
 * @returns <string> - the storage path of the verifier contract file.
 */
export declare const getVerifierContractStorageFilePath: (circuitPrefix: string, completeVerifierContractFilename: string) => string;
/**
 * Get transcript file path tied to a particular circuit of a ceremony in the storage.
 * @notice each R1CS file in the storage must be stored in the following path: `circuits/<circuitPrefix>/<completeTranscriptFilename>`.
 * nb. This is a rule that must be satisfied. This is NOT an optional convention.
 * @param circuitPrefix <string> - the prefix of the circuit.
 * @param completeTranscriptFilename <string> - the complete transcript filename (name + ext).
 * @returns <string> - the storage path of the transcript file.
 */
export declare const getTranscriptStorageFilePath: (circuitPrefix: string, completeTranscriptFilename: string) => string;
//# sourceMappingURL=storage.d.ts.map